"
## create past season basis
season_past_basis <- ns(1:dim(season_past_matrix_hosp)[2],knots=seq(1,dim(season_past_matrix_hosp)[2]-14,by=14))
## create current season basis
season_current_basis <- ns(1:length(season_current_hosp),knots=seq(1,length(season_current_hosp)-14,by=14))
## get out of sample basis for 30 days ahead
season_current_basis_oos <- splines:::predict.ns(season_current_basis,newx=seq(length(season_current_hosp),length(season_current_hosp)+30))
model_code <- "
model
{
for (j in 1:num_past_seasons){
phi[j]  ~ dbeta(1,100)
## Spline model for previous wave
season_previous_spline[1,j] <- exp(intercept_b[j] + b[j]*1)
for (i in 2:T_previous){
season_past_hosp[j,i] ~ dnegbin(p_past[i,j],r)
p_past[i,j] <- r/(r+season_previous_spline[i,j])
f_t_past[i,j] <- intercept_b[j] + b[j]*i
exp_f_t_past[i,j] <- exp(intercept_b[j] + b[j]*i)
season_previous_spline[i,j] <- exp(f_t_past[i,j] - phi[j]*sum(exp_f_t_past[i,j]))
}
for (i in 1:N_knots_season_past_basis) {
beta_w1[i,j] ~ dnorm(beta[i], 100)
}
b[j] ~ dnorm(0,.001)
intercept_b[j] ~ dnorm(0,.001)
}
for (i in 1:N_knots_season_current_basis) {
beta_w2[i] ~ dnorm(beta[i], 100)
}
a ~ dnorm(0,.001)
intercept ~ dnorm(0,.001)
beta[1] ~ dnorm(0, .0001)
for (i in 2:max(N_knots_season_past_basis,N_knots_season_current_basis)) {
beta[i] ~ dnorm(beta[i-1], 1)
}
sigma_b ~ dt(0, 10^-2, 1)T(0,)
phi2 ~ dbeta(1,100)
r <-  10
}
"
## create past season basis
season_past_basis <- ns(1:dim(season_past_matrix_hosp)[2],knots=seq(1,dim(season_past_matrix_hosp)[2]-14,by=14))
model_data <- list( T_previous = dim(season_past_matrix_hosp)[2],
num_past_seasons =  dim(season_past_matrix_hosp)[1],
season_past_hosp =season_past_matrix_hosp,
# season_current_hosp =  season_current_hosp,
#season_current_basis = season_current_basis,
T_latest = length(season_current_hosp),
season_past_basis = season_past_basis,
N_knots_season_past_basis = dim(season_past_basis)[2],
N_knots_season_current_basis = dim(season_current_basis)[2])#,
model_data <- list( T_previous = dim(season_past_matrix_hosp)[2],
num_past_seasons =  dim(season_past_matrix_hosp)[1],
season_past_hosp =season_past_matrix_hosp,
# season_current_hosp =  season_current_hosp,
#season_current_basis = season_current_basis,
# T_latest = length(season_current_hosp),
season_past_basis = season_past_basis,
N_knots_season_past_basis = dim(season_past_basis)[2],
N_knots_season_current_basis = dim(season_current_basis)[2])#,
model_data <- list( T_previous = dim(season_past_matrix_hosp)[2],
num_past_seasons =  dim(season_past_matrix_hosp)[1],
season_past_hosp =season_past_matrix_hosp,
# season_current_hosp =  season_current_hosp,
#season_current_basis = season_current_basis,
# T_latest = length(season_current_hosp),
season_past_basis = season_past_basis,
N_knots_season_past_basis = dim(season_past_basis)[2])#,
# Choose the parameters to watch
model_parameters <- c("season_current_spline","spline_forecast_current","phi","phi2")
# Run the model
model_run <- jags(
data = model_data,
parameters.to.save = model_parameters,
model.file = textConnection(model_code),
n.chains = 4, # Number of different starting positions
n.iter = 1000, # Number of iterations
n.burnin = 200, # Number of iterations to remove at start
n.thin = 2
) # Amo
model_code <- "
model
{
for (j in 1:num_past_seasons){
phi[j]  ~ dbeta(1,100)
## Spline model for previous wave
season_previous_spline[1,j] <- exp(intercept_b[j] + b[j]*1)
for (i in 2:T_previous){
season_past_hosp[j,i] ~ dnegbin(p_past[i,j],r)
p_past[i,j] <- r/(r+season_previous_spline[i,j])
f_t_past[i,j] <- intercept_b[j] + b[j]*i
exp_f_t_past[i,j] <- exp(intercept_b[j] + b[j]*i)
season_previous_spline[i,j] <- exp(f_t_past[i,j] - phi[j]*sum(exp_f_t_past[i,j]))
}
for (i in 1:N_knots_season_past_basis) {
beta_w1[i,j] ~ dnorm(beta[i], 100)
}
b[j] ~ dnorm(0,.001)
intercept_b[j] ~ dnorm(0,.001)
}
a ~ dnorm(0,.001)
intercept ~ dnorm(0,.001)
beta[1] ~ dnorm(0, .0001)
for (i in 2:max(N_knots_season_past_basis)) {
beta[i] ~ dnorm(beta[i-1], 1)
}
sigma_b ~ dt(0, 10^-2, 1)T(0,)
phi2 ~ dbeta(1,100)
r <-  10
}
"
## create past season basis
season_past_basis <- ns(1:dim(season_past_matrix_hosp)[2],knots=seq(1,dim(season_past_matrix_hosp)[2]-14,by=14))
model_data <- list( T_previous = dim(season_past_matrix_hosp)[2],
num_past_seasons =  dim(season_past_matrix_hosp)[1],
season_past_hosp =season_past_matrix_hosp,
# season_current_hosp =  season_current_hosp,
#season_current_basis = season_current_basis,
# T_latest = length(season_current_hosp),
season_past_basis = season_past_basis,
N_knots_season_past_basis = dim(season_past_basis)[2])#,
# Choose the parameters to watch
model_parameters <- c("season_current_spline","spline_forecast_current","phi","phi2")
# Run the model
model_run <- jags(
data = model_data,
parameters.to.save = model_parameters,
model.file = textConnection(model_code),
n.chains = 4, # Number of different starting positions
n.iter = 1000, # Number of iterations
n.burnin = 200, # Number of iterations to remove at start
n.thin = 2
) # Amo
model_code <- "
model
{
for (j in 1:num_past_seasons){
phi[j]  ~ dbeta(1,100)
## Spline model for previous wave
season_previous_spline[1,j] <- exp(intercept_b[j] + b[j]*1)
for (i in 2:T_previous){
season_past_hosp[j,i] ~ dnegbin(p_past[i,j],r)
p_past[i,j] <- r/(r+season_previous_spline[i,j])
f_t_past[i,j] <- inprod(basis_[i,], beta_w1[,j])#intercept_b[j] + b[j]*i
exp_f_t_past[i,j] <- exp(f_t_past[i,j])
season_previous_spline[i,j] <- exp(f_t_past[i,j] - phi[j]*sum(exp_f_t_past[i,j]))
}
for (i in 1:N_knots_season_past_basis) {
beta_w1[i,j] ~ dnorm(beta[i], 100)
}
b[j] ~ dnorm(0,.001)
intercept_b[j] ~ dnorm(0,.001)
}
a ~ dnorm(0,.001)
intercept ~ dnorm(0,.001)
beta[1] ~ dnorm(0, .0001)
for (i in 2:max(N_knots_season_past_basis)) {
beta[i] ~ dnorm(beta[i-1], 1)
}
sigma_b ~ dt(0, 10^-2, 1)T(0,)
phi2 ~ dbeta(1,100)
r <-  10
}
"
## create past season basis
season_past_basis <- ns(1:dim(season_past_matrix_hosp)[2],knots=seq(1,dim(season_past_matrix_hosp)[2]-14,by=14))
model_data <- list( T_previous = dim(season_past_matrix_hosp)[2],
num_past_seasons =  dim(season_past_matrix_hosp)[1],
season_past_hosp =season_past_matrix_hosp,
# season_current_hosp =  season_current_hosp,
#season_current_basis = season_current_basis,
# T_latest = length(season_current_hosp),
season_past_basis = season_past_basis,
N_knots_season_past_basis = dim(season_past_basis)[2])#,
# Choose the parameters to watch
model_parameters <- c("season_previous_spline","spline_forecast_current","phi","phi2")
# Run the model
model_run <- jags(
data = model_data,
parameters.to.save = model_parameters,
model.file = textConnection(model_code),
n.chains = 4, # Number of different starting positions
n.iter = 1000, # Number of iterations
n.burnin = 200, # Number of iterations to remove at start
n.thin = 2
) # Amo
model_code <- "
model
{
for (j in 1:num_past_seasons){
phi[j]  ~ dbeta(1,100)
## Spline model for previous wave
season_previous_spline[1,j] <- exp(intercept_b[j] + b[j]*1)
for (i in 2:T_previous){
season_past_hosp[j,i] ~ dnegbin(p_past[i,j],r)
p_past[i,j] <- r/(r+season_previous_spline[i,j])
f_t_past[i,j] <- inprod(season_past_basis[i,], beta_w1[,j])#intercept_b[j] + b[j]*i
exp_f_t_past[i,j] <- exp(f_t_past[i,j])
season_previous_spline[i,j] <- exp(f_t_past[i,j] - phi[j]*sum(exp_f_t_past[i,j]))
}
for (i in 1:N_knots_season_past_basis) {
beta_w1[i,j] ~ dnorm(beta[i], 100)
}
b[j] ~ dnorm(0,.001)
intercept_b[j] ~ dnorm(0,.001)
}
a ~ dnorm(0,.001)
intercept ~ dnorm(0,.001)
beta[1] ~ dnorm(0, .0001)
for (i in 2:max(N_knots_season_past_basis)) {
beta[i] ~ dnorm(beta[i-1], 1)
}
sigma_b ~ dt(0, 10^-2, 1)T(0,)
phi2 ~ dbeta(1,100)
r <-  10
}
"
## create past season basis
season_past_basis <- ns(1:dim(season_past_matrix_hosp)[2],knots=seq(1,dim(season_past_matrix_hosp)[2]-14,by=14))
model_data <- list( T_previous = dim(season_past_matrix_hosp)[2],
num_past_seasons =  dim(season_past_matrix_hosp)[1],
season_past_hosp =season_past_matrix_hosp,
# season_current_hosp =  season_current_hosp,
#season_current_basis = season_current_basis,
# T_latest = length(season_current_hosp),
season_past_basis = season_past_basis,
N_knots_season_past_basis = dim(season_past_basis)[2])#,
# Choose the parameters to watch
model_parameters <- c("season_previous_spline","spline_forecast_current","phi","phi2")
# Run the model
model_run <- jags(
data = model_data,
parameters.to.save = model_parameters,
model.file = textConnection(model_code),
n.chains = 4, # Number of different starting positions
n.iter = 1000, # Number of iterations
n.burnin = 200, # Number of iterations to remove at start
n.thin = 2
) # Amo
model_run$BUGSoutput$sims.list$season_previous_spline
dim(model_run$BUGSoutput$sims.list$season_previous_spline)
model_run$BUGSoutput$sims.list$season_previous_spline[,4]
model_run$BUGSoutput$sims.list$season_previous_spline[,,4]
length(model_run$BUGSoutput$sims.list$season_previous_spline[,,4])
apply(model_run$BUGSoutput$sims.list$season_previous_spline[,,4],MARGIN = c(1,2),mean)
post_means <- apply(model_run$BUGSoutput$sims.list$season_previous_spline[,,4],MARGIN = c(1,2),mean)
print (post_means)
dim(post_means)
post_means <- apply(model_run$BUGSoutput$sims.list$season_previous_spline,MARGIN = c(1,2),mean)
dim(post_means)
post_means <- apply(model_run$BUGSoutput$sims.list$season_previous_spline,MARGIN = c(3),mean)
dim(post_means)
post_means
current_season <- model_run$BUGSoutput$sims.list$season_previous_spline[,,4]
current_season
dim(current_season)
plot(colMeans(current_season))
plot(colMeans(current_season)[2:160])
lines(current_wave)
plot(colMeans(current_season)[2:160],type='l')
lines(current_wave)
plot(colMeans(current_season)[2:160],type='l')
lines(wave_matrix[,4])
wave_matrix[,4]
wave_matrix[4,]
plot(colMeans(current_season)[2:160],type='l')
lines(wave_matrix[4,])
plot(colMeans(current_season)[2:20],type='l')
plot(colMeans(current_season)[2:200],type='l')
lines(wave_matrix[4,])
plot(colMeans(current_season)[2:200],type='l',ylim=c(0,100))
lines(wave_matrix[4,])
plot(colMeans(current_season)[1:200],type='l',ylim=c(0,100))
lines(wave_matrix[4,])
model_code <- "
model
{
for (j in 1:num_past_seasons){
phi[j]  ~ dbeta(1,100)
## Spline model for previous wave
season_previous_spline[1,j] <- exp(intercept_b[j] + b[j]*1)
for (i in 2:T_previous){
season_past_hosp[j,i] ~ dnegbin(p_past[i,j],r)
p_past[i,j] <- r/(r+season_previous_spline[i,j])
f_t_past[i,j] <- inprod(season_past_basis[i,], beta_w1[,j])#intercept_b[j] + b[j]*i
exp_f_t_past[i,j] <- exp(f_t_past[i,j])
season_previous_spline[i,j] <- exp(f_t_past[i,j] - phi[j]*sum(exp_f_t_past[i,j]))
}
for (i in 1:N_knots_season_past_basis) {
beta_w1[i,j] ~ dnorm(beta[i], 10)
}
b[j] ~ dnorm(0,.001)
intercept_b[j] ~ dnorm(0,.001)
}
a ~ dnorm(0,.001)
intercept ~ dnorm(0,.001)
beta[1] ~ dnorm(0, .0001)
for (i in 2:max(N_knots_season_past_basis)) {
beta[i] ~ dnorm(beta[i-1], 1)
}
sigma_b ~ dt(0, 10^-2, 1)T(0,)
phi2 ~ dbeta(1,100)
r <-  10
}
"
## create past season basis
season_past_basis <- ns(1:dim(season_past_matrix_hosp)[2],knots=seq(1,dim(season_past_matrix_hosp)[2]-14,by=14))
model_data <- list( T_previous = dim(season_past_matrix_hosp)[2],
num_past_seasons =  dim(season_past_matrix_hosp)[1],
season_past_hosp =season_past_matrix_hosp,
# season_current_hosp =  season_current_hosp,
#season_current_basis = season_current_basis,
# T_latest = length(season_current_hosp),
season_past_basis = season_past_basis,
N_knots_season_past_basis = dim(season_past_basis)[2])#,
# Choose the parameters to watch
model_parameters <- c("season_previous_spline","spline_forecast_current","phi","phi2")
# Run the model
model_run <- jags(
data = model_data,
parameters.to.save = model_parameters,
model.file = textConnection(model_code),
n.chains = 4, # Number of different starting positions
n.iter = 1000, # Number of iterations
n.burnin = 200, # Number of iterations to remove at start
n.thin = 2
) # Amo
current_season <- model_run$BUGSoutput$sims.list$season_previous_spline[,,4]
dim(current_season)
plot(colMeans(current_season)[1:200],type='l',ylim=c(0,100))
lines(wave_matrix[4,])
source("~/semimech/R/semimech2.R", echo=TRUE)
forecast_date <- "2022-01-17"#args[1]
cases <- covidcast_signal(
data_source = "hhs",
signal = "confirmed_admissions_covid_1d",
time_type = "day",
geo_type = "state",as_of = as.Date(forecast_date) )
cases <- cases[cases$time_value >= "2020-08-01",]
cases <- cases %>% group_by(geo_value) %>% mutate(value = zoo::rollmean(value,7,fill=0)) %>% ungroup()
states <- unique(cases$geo_value)
states <- setdiff(states,c("as","pr","hi","vi"))
fit_res <- list()
print (geo_val)
mydfcovid <- cases[cases$geo_value ==geo_val ,]$value
smoothed_deriv <- c(0,diff(lowess(mydfcovid/max(mydfcovid,na.rm=T),f=.15)$y))
wave_starts <- c()
for (t in 2:length(smoothed_deriv)){
if (!is.na(smoothed_deriv[t-1]) & !is.na(smoothed_deriv[t])){
if (smoothed_deriv[t-1] < 0 & smoothed_deriv[t] >0){
wave_starts <-c(wave_starts,t)
}
}
}
wave_matrix <-matrix(NA,nrow=length(wave_starts)-1,ncol=1000)
if (length(wave_starts) > 1){
for (wave_start in 2:length(wave_starts)){
to_replace <- mydfcovid[wave_starts[wave_start-1]:wave_starts[wave_start]]
while (length(to_replace) < 1000){
to_replace <- c(to_replace,NA)
}
wave_matrix[wave_start-1,] <- to_replace
}
NAindex <-function(z){ min(which(is.na(z)))}
longest_wave_length <- max(apply(wave_matrix,1,NAindex))
wave_matrix <- round(wave_matrix[,1:longest_wave_length])
current_wave <- round(mydfcovid[wave_starts[length(wave_starts)]:length(mydfcovid)])
if (is.null(dim(wave_matrix))){
wave_matrix <- matrix(wave_matrix,nrow=1)
}
}
current_wave[tail(1:length(current_wave),3)] <- NA
forecast <- run_semi_mech(season_past_matrix_hosp = wave_matrix,season_current_hosp =current_wave )
plot(colMeans(forecast[[1]]),type='l',ylim=c(0,10000),col='red')
lines(current_wave)
while(length(current_wave) < dim(wave_matrix)[2]){
current_wave <- c(current_wave,NA)
}
wave_matrix <- rbind(wave_matrix,matrix(current_wave,nrow=1))
forecast <- run_semi_mech(season_past_matrix_hosp = wave_matrix,season_current_hosp =current_wave )
plot(colMeans(forecast[[1]]),type='l',ylim=c(0,10000),col='red')
lines(current_wave)
wave_matrix
dims <-  model_run$BUGSoutput$sims.list$season_previous_spline
dims
dims[4]
dims <-  dim(model_run$BUGSoutput$sims.list$season_previous_spline)
dims
current_season <- model_run$BUGSoutput$sims.list$season_previous_spline[,,dims[3]]
source("~/semimech/R/semimech2.R", echo=TRUE)
forecast <- run_semi_mech(season_past_matrix_hosp = wave_matrix,season_current_hosp =current_wave )
plot(colMeans(forecast[[1]]),type='l',ylim=c(0,10000),col='red')
lines(current_wave)
dims[]forecast
forecast
forecast[[1]]
dim(forecast[[1]])
colMeans(dim(forecast[[1]]))
source("~/semimech/R/semimech2.R", echo=TRUE)
print (geo_val)
mydfcovid <- cases[cases$geo_value ==geo_val ,]$value
smoothed_deriv <- c(0,diff(lowess(mydfcovid/max(mydfcovid,na.rm=T),f=.15)$y))
wave_starts <- c()
for (t in 2:length(smoothed_deriv)){
if (!is.na(smoothed_deriv[t-1]) & !is.na(smoothed_deriv[t])){
if (smoothed_deriv[t-1] < 0 & smoothed_deriv[t] >0){
wave_starts <-c(wave_starts,t)
}
}
}
wave_matrix <-matrix(NA,nrow=length(wave_starts)-1,ncol=1000)
if (length(wave_starts) > 1){
for (wave_start in 2:length(wave_starts)){
to_replace <- mydfcovid[wave_starts[wave_start-1]:wave_starts[wave_start]]
while (length(to_replace) < 1000){
to_replace <- c(to_replace,NA)
}
wave_matrix[wave_start-1,] <- to_replace
}
NAindex <-function(z){ min(which(is.na(z)))}
longest_wave_length <- max(apply(wave_matrix,1,NAindex))
wave_matrix <- round(wave_matrix[,1:longest_wave_length])
current_wave <- round(mydfcovid[wave_starts[length(wave_starts)]:length(mydfcovid)])
if (is.null(dim(wave_matrix))){
wave_matrix <- matrix(wave_matrix,nrow=1)
}
}
current_wave[tail(1:length(current_wave),3)] <- NA
while(length(current_wave) < dim(wave_matrix)[2]){
current_wave <- c(current_wave,NA)
}
wave_matrix <- rbind(wave_matrix,matrix(current_wave,nrow=1))
forecast <- run_semi_mech(season_past_matrix_hosp = wave_matrix,season_current_hosp =current_wave )
plot(colMeans(forecast[[1]]),type='l',ylim=c(0,10000),col='red')
plot(colMeans(forecast[[1]]),type='l',col='red')
lines(current_wave)
current_wave
source("~/semimech/R/semimech2.R", echo=TRUE)
source("~/semimech/R/semimech2.R", echo=TRUE)
library(rjags)
library(R2jags)
library(splines)
library(rjags)
library(R2jags)
library(splines)
library(covidcast)
library(splines)
library(rjags)
library(R2jags)
library(dplyr)
library(lubridate)
args = commandArgs(trailingOnly=TRUE)
forecast_date <- "2022-01-17"#args[1]
cases <- covidcast_signal(
data_source = "hhs",
signal = "confirmed_admissions_covid_1d",
time_type = "day",
geo_type = "state",as_of = as.Date(forecast_date) )
cases <- cases[cases$time_value >= "2020-08-01",]
cases <- cases %>% group_by(geo_value) %>% mutate(value = zoo::rollmean(value,7,fill=0)) %>% ungroup()
states <- unique(cases$geo_value)
states <- setdiff(states,c("as","pr","hi","vi"))
fit_res <- list()
print (geo_val)
mydfcovid <- cases[cases$geo_value ==geo_val ,]$value
geo_val <- "ca"
print (geo_val)
mydfcovid <- cases[cases$geo_value ==geo_val ,]$value
smoothed_deriv <- c(0,diff(lowess(mydfcovid/max(mydfcovid,na.rm=T),f=.15)$y))
wave_starts <- c()
for (t in 2:length(smoothed_deriv)){
if (!is.na(smoothed_deriv[t-1]) & !is.na(smoothed_deriv[t])){
if (smoothed_deriv[t-1] < 0 & smoothed_deriv[t] >0){
wave_starts <-c(wave_starts,t)
}
}
}
wave_matrix <-matrix(NA,nrow=length(wave_starts)-1,ncol=1000)
if (length(wave_starts) > 1){
for (wave_start in 2:length(wave_starts)){
to_replace <- mydfcovid[wave_starts[wave_start-1]:wave_starts[wave_start]]
while (length(to_replace) < 1000){
to_replace <- c(to_replace,NA)
}
wave_matrix[wave_start-1,] <- to_replace
}
NAindex <-function(z){ min(which(is.na(z)))}
longest_wave_length <- max(apply(wave_matrix,1,NAindex))
wave_matrix <- round(wave_matrix[,1:longest_wave_length])
current_wave <- round(mydfcovid[wave_starts[length(wave_starts)]:length(mydfcovid)])
if (is.null(dim(wave_matrix))){
wave_matrix <- matrix(wave_matrix,nrow=1)
}
}
current_wave[tail(1:length(current_wave),3)] <- NA
while(length(current_wave) < dim(wave_matrix)[2]){
current_wave <- c(current_wave,NA)
}
wave_matrix <- rbind(wave_matrix,matrix(current_wave,nrow=1))
forecast <- run_semi_mech(season_past_matrix_hosp = wave_matrix,season_current_hosp =current_wave )
plot(colMeans(forecast[[1]]),type='l',col='red')
forecast <- run_semi_mech(season_past_matrix_hosp = wave_matrix,season_current_hosp =current_wave )
source("~/semimech/R/semimech2.R", echo=TRUE)
forecast <- run_semi_mech(season_past_matrix_hosp = wave_matrix,season_current_hosp =current_wave )
source("~/semimech/R/semimech2.R", echo=TRUE)
forecast <- run_semi_mech(season_past_matrix_hosp = wave_matrix,season_current_hosp =current_wave )
plot(colMeans(forecast[[1]]),type='l',col='red')
lines(current_wave)
plot(colMeans(forecast[[1]]),type='l',col='red',ylim=c(0,1000))
plot(colMeans(forecast[[1]]),type='l',col='red',ylim=c(0,10000))
lines(current_wave)
